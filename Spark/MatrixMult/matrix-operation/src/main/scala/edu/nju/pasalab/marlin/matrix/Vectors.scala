package edu.nju.pasalab.marlin.matrix
/**
 * Notice: the code in this file is copy from MLlib, to make it compatible
 */

import java.io.{DataOutput, DataInput}
import java.lang.{Iterable => JavaIterable, Integer => JavaInteger, Double => JavaDouble}
import java.util.Arrays

import scala.annotation.varargs
import scala.collection.JavaConverters._
import scala.reflect.ClassTag
import scala.{specialized => spec}

import breeze.linalg.{Vector => BV, DenseVector => BDV, SparseVector => BSV}
import org.apache.hadoop.io.Writable

/**
 * Represents a numeric vector, whose index type is Int and value type is Double.
 */
trait Vector extends Serializable  with Writable {

  /**
   * Size of the vector.
   */
  def size: Int

  /**
   * Converts the instance to a double array.
   */
  def toArray: Array[Double]

  override def equals(other: Any): Boolean = {
    other match {
      case v: Vector =>
        Arrays.equals(this.toArray, v.toArray)
      case _ => false
    }
  }

  override def hashCode(): Int = Arrays.hashCode(this.toArray)

//  def add(v: Vector): Vector

  /**
   * Converts the instance to a breeze vector.
   */
  private[matrix] def toBreeze: BV[Double]

  /**
   * Gets the value of the ith element.
   * @param i index
   */
  private[matrix] def apply(i: Int): Double = toBreeze(i)
}

/**
 * Factory methods for [[edu.nju.pasalab.marlin.matrix.Vector]].
 *
 */
object Vectors {

  /**
   * Creates a dense vector from its values.
   */
  @varargs
  def dense(firstValue: Double, otherValues: Double*): DenseVector =
    new DenseVector((firstValue +: otherValues).toArray)

  // A dummy implicit is used to avoid signature collision with the one generated by @varargs.
  /**
   * Creates a dense vector from a double array.
   */
  def dense(values: Array[Double]): DenseVector = new DenseVector(values)

  /**
   * Creates a sparse vector providing its index array and value array.
   *
   * @param size vector size.
   * @param indices index array, must be strictly increasing.
   * @param values value array, must have the same length as indices.
   */
  def sparse(size: Int, indices: Array[Int], values: Array[Double]): Vector =
    new SparseVector(size, indices, values)

  /**
   * Creates a sparse vector using unordered (index, value) pairs.
   *
   * @param size vector size.
   * @param elements vector elements in (index, value) pairs.
   */
  def sparse(size: Int, elements: Seq[(Int, Double)]): SparseVector = {
    require(size > 0)

    val (indices, values) = elements.sortBy(_._1).unzip
    var prev = -1
    indices.foreach { i =>
      require(prev < i, s"Found duplicate indices: $i.")
      prev = i
    }
    require(prev < size)

    new SparseVector(size, indices.toArray, values.toArray)
  }

  /**
   * Creates a sparse vector using unordered (index, value) pairs in a Java friendly way.
   *
   * @param size vector size.
   * @param elements vector elements in (index, value) pairs.
   */
  def sparse(size: Int, elements: JavaIterable[(JavaInteger, JavaDouble)]): Vector = {
    sparse(size, elements.asScala.map { case (i, x) =>
      (i.intValue(), x.doubleValue())
    }.toSeq)
  }

  /**
   * Creates a vector instance from a breeze vector.
   */
  private[matrix] def fromBreeze(v: BDV[Double]): DenseVector = {
    if (v.offset == 0 && v.stride == 1) {
      new DenseVector(v.data)
    } else {
      new DenseVector(v.toArray)  // Can't use underlying array directly, so make a new one
    }
  }

  /**
   * Creates a vector instance from a breeze vector.
   */
  private[matrix] def fromBreeze(v: BSV[Double]): SparseVector = {
    if (v.index.length == v.used) {
      new SparseVector(v.length, v.index, v.data)
    } else {
      new SparseVector(v.length, v.index.slice(0, v.used), v.data.slice(0, v.used))
    }
  }
}


/**
 * A dense vector represented by a value array.
 */
class DenseVector extends Vector  {
  var inner: Option[BDV[Double]] = None

  var values: Option[Array[Double]] = None

  def this(v: BDV[Double]) {
    this()
    inner = Some(v)
    values = Some(inner.get.data)
  }

  def this(array: Array[Double]) {
    this()
    inner = Some(new BDV[Double](array))
    values = Some(inner.get.data)
  }

  override def size: Int = inner.get.length

  def length = size

  override def toString: String = values.mkString(",")

  override def toArray: Array[Double] = values.get

  private[marlin]  def toBreeze: BV[Double] = inner.get

  override def apply(i: Int) = inner.get(i)

  override def write(out: DataOutput) {
    out.writeInt(values.get.length)
    for (v <- values.get){
      out.writeDouble(v)
    }
  }

  override def readFields(in: DataInput)  {
    val length = in.readInt()
    inner = Some(new BDV[Double](length))
    for (i <- 0 until length){
      inner.get(i) = in.readDouble()
    }
  }

  def add(other: Vector): DenseVector = {
    other.isInstanceOf[DenseVector] match {
      case true => new DenseVector(this.inner.get + other.asInstanceOf[DenseVector].inner.get)
      case _ => throw new IllegalArgumentException(s"Not supported add-operator between DenseVector and SparseVector")
    }
  }

  def subtract(other: Vector): Vector = {
    other.isInstanceOf[DenseVector] match {
      case true => new DenseVector(this.inner.get - other.asInstanceOf[DenseVector].inner.get)
      case _ => throw new IllegalArgumentException(s"Not supported add-operator between DenseVector and SparseVector")
    }
  }

  /** used for display the vector**/
  private[marlin] def print(length: Int = size): String ={
    if (length >= size){
      toArray.mkString(",")
    }else {
      toArray.take(length).mkString(",") + " ..."+ (size - length) +" elements more..."
    }
  }
}

/**
 * A sparse vector represented by an index array and an value array.
 *
 */
class SparseVector extends Vector {
  var length = 0
  var indices: Option[Array[Int]] = None
  var values: Option[Array[Double]] = None

  override def size: Int = length

  def this(size: Int, indices: Array[Int], values: Array[Double]) {
    this()
    length = size
    this.indices = Some(indices)
    this.values = Some(values)
  }

  def isEmpty: Boolean = {
    length == 0
  }

  override def toString: String = {
    "(" + size + "," + indices.zip(values).mkString("[", "," ,"]") + ")"
  }

  override def toArray: Array[Double] = {
    val data = new Array[Double](size)
    var i = 0
    val nnz = indices.get.length
    while (i < nnz) {
      data(indices.get(i)) = values.get(i)
      i += 1
    }
    data
  }

  private[matrix]  def toBreeze: BV[Double] = new BSV[Double](indices.get, values.get, size)

  override def write(out: DataOutput) {
    out.writeInt(length)
    out.writeInt(indices.get.length)
    out.writeInt(values.get.length)
    for ( i <- indices.get){
      out.writeInt(i)
    }
    for ( v <- values.get) {
      out.writeDouble(v)
    }
  }

  override def readFields(in: DataInput) {
    length = in.readInt()
    val indexLen = in.readInt()
    val valLen = in.readInt()
    indices = Some(Array.ofDim[Int](indexLen))
    values = Some(Array.ofDim[Double](valLen))

    for (i <- 0 until indexLen){
      indices.get(i) = in.readInt()
    }

    for (i <- 0 until valLen){
      values.get(i) = in.readDouble()
    }
  }
}
